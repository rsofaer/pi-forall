module Graph where

import Nat
import Vec
import List
import Fin 

map_with_index' : [A:Type] -> [B:Type] -> [n:Nat] -> Nat -> (Nat -> A -> B) -> Vec A n -> Vec B n
map_with_index' = \[A][B][n] idx f v.
  case v of 
    Nil -> Nil
    Cons [m] x xs -> Cons [m] (f idx  x) (map_with_index' [A][B] [m] (Succ idx) f xs)

map_with_index : [A:Type] -> [B:Type] -> [n:Nat] -> (Nat -> A -> B) -> Vec A n -> Vec B n
map_with_index = \[A][B][n] f v . map_with_index' [A] [B][n] (Zero) f v
vecmap = map_with_index

data Maybe (a : Type) : Type where
  Nothing
  Just of (a)
 
Node : Type
Node = Nat

data Graph (n : Nat) : Type where
  G of (Vec (List Node) n)

idxl : [a: Type] -> List a -> Nat -> (Maybe a)
idxl = \[a] lst i . case lst of 
  Nil -> Nothing
  Cons h l' -> case i of
    Zero -> Just h
    Succ j -> idxl [a] l' j

idxv : [a: Type] -> [n: Nat] -> Vec a n -> (i: Fin n) -> (a)
idxv = \[a] [n] v i . case i of 
  Zero [_] -> case v of 
    Cons [n'] h l' -> h
  Succ [nj'] j -> case v of
    Cons [n'] h l' -> idxv [a] [n'] l' j

successors : (n: Nat) -> (Graph n) -> (u : Fin n) -> (List Node)
successors = \n g u . case g of 
    G v -> case v of 
      Nil -> Nil
      Cons [m] h tl -> idxv [List Node] [Succ m] v u 

--successors = \n g u . case n of 
--  Zero -> Nil
--  Succ m -> case g of 
--    G v -> idxv [List Node] [n] v u 

contains_nat : List Nat -> Nat -> Bool
contains_nat = \l x . case l of
  Nil -> False
  Cons h tl -> if (nat_eq x h) then True else (contains_nat tl x)
 
-- Rather than explicit contains, just use filter equals?
is_pred : (n: Nat) -> (Graph n) -> (u: Fin n) -> (v: Fin n) -> Maybe (Fin n) -- Return u if u is a predecessor of v, else nothing
is_pred = \n g u v . let succs = successors n g v in
  case (contains_nat succs (toNat [n] u)) of
    False -> Nothing
    True -> Just v

contains_maybe : [a: Type] -> a -> Nat -> Nat -> List Nat -> Maybe Nat
contains_maybe = \[a] ret n idx lst . case (contains_nat lst n) of
  False -> Nothing
  True -> Just idx

--maybe_pred_single : Node -> Node -> Maybe Node
--maybe_pred_single = \target n . case n of
--  AdjList n_succs -> case filter [Node] (\x . x = target) n_succs of
--    Nil -> Nothing
--    Cons a a' -> Just a

maybe_preds : [n: Nat] -> (g: Graph n) -> Fin n -> (Vec (Maybe Node) n)
maybe_preds = \[n] g u. case g of
  G v -> vecmap [List Node] [Maybe Node] [n] (contains_maybe [Node]  (toNat [n] u) (toNat [n] u)) v

maybe_v2l : [A: Type] -> [n: Nat] -> Vec (Maybe A) n -> List A
maybe_v2l = \[A][n] v .
  case v of
    Nil -> Nil
    Cons [n'] x xs -> let p = (maybe_v2l [A] [n'] xs) in
      case x of
        Just y -> Cons y p
        Nothing -> p


predecessors : [n: Nat] -> (g : Graph n) -> Fin n -> (List Node)
predecessors = \[n] g u . let pred_or_nothing_vec = maybe_preds [n] g u in
  maybe_v2l [Node] [n] pred_or_nothing_vec

GraphConstraint : Type
GraphConstraint = [n: Nat] -> Graph n -> Bool 

--GraphConstraint : Type
--GraphConstraint = [n: Nat] -> Graph n -> Maybe (Graph n)
--ConstrainedGraph : Type
--ConstrainedGraph = { n : Nat | { g: Graph n | { con : GraphConstraint | con [n] g = Just g }}}


ConstrainedGraph : Type
ConstrainedGraph = { n : Nat | { g: Graph n | { con : GraphConstraint | con [n] g = True }}}
--ConstrainedGraph = (n : Nat * (g: Graph n * ( con : GraphConstraint * con [n] g = True )))
SizeAndGraph : Type
SizeAndGraph  = {n: Nat | Graph n}

sizeFromSG : SizeAndGraph -> Nat
sizeFromSG = \sg . let (s, g) = sg in s
graphFromSG : (sg: SizeAndGraph) -> Graph (sizeFromSG sg)
graphFromSG = \sg . let (s, g) = sg in g

con_graph_size : ConstrainedGraph -> Nat
con_graph_size = \  g. (fst [Nat] 
  [\n . (Sigma (Graph n) (\g. Sigma GraphConstraint (\con. (con [n] g = True))))] g) 

con_graph_graphcon : (cg: ConstrainedGraph) -> { g: Graph (con_graph_size cg) | { con : GraphConstraint | con [con_graph_size cg] g = True }}
con_graph_graphcon = \ g. (snd 
  [Nat] 
  [\n . Sigma (Graph n) (\g. Sigma GraphConstraint (\con. ((con [n] g) = True)))]
  g) 

con_graph_graph : (cg: ConstrainedGraph) -> Graph (con_graph_size cg)
con_graph_graph = \ cg. let (n, a) = cg in
  let (g, b) = a in g

con_graph_con_and_proof : (cg : ConstrainedGraph) -> { con : GraphConstraint | con [con_graph_size cg] (con_graph_graph cg) = True }
con_graph_con_and_proof = \ cg. let (n, a) = cg in
  let (g, b) = a in b

con_graph_con : ConstrainedGraph -> GraphConstraint
con_graph_con = \cg . let (n, wrapped_g) = cg in let (g, con') = wrapped_g in (fst [GraphConstraint] [\con. ((con [n] g) = True)] con')

constrained_graph_constraint_true : (cg : ConstrainedGraph) -> (con_graph_con cg) [con_graph_size cg] (con_graph_graph cg) = True
constrained_graph_constraint_true = PRINTME
--inwardSpokeConstraint : GraphConstraint
--inwardSpokeConstraint = \[n] g . case g of
--  G v -> let toZ = (\x eq_bool x 0)
-- Graph in which every node has an edge going to node 0
-- InwardSpokeGraph : Type
-- InwardSpokeGraph = {n : Nat | ((Graph n) *  }