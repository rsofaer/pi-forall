module Graph where

import Nat
import Vec
import List
import Fin 
import Product

map_with_index' : [A:Type] -> [B:Type] -> [n:Nat] -> Fin n -> ((Fin n * A) -> B) -> Vec A n -> Vec B n
map_with_index' = \[A][B][n] idx f v.
  case v of 
    Nil -> Nil
    Cons [m] x xs -> Cons [m] (f (idx * x)) (map_with_index' [A][B] [m] (Succ idx) f xs)

map_with_index = \[A][B][n] f v . map_with_index' [A] [B][n] (Zero [1]) f v
vecmap = map_with_index

data Maybe (a : Type) : Type where
  Nothing
  Just of (a)
 
Node : Type
Node = Nat

data Graph (n : Nat) : Type where
  G of (Vec (List Node) n)

idxl : [a: Type] -> List a -> Nat -> (Maybe a)
idxl = \[a] lst i . case lst of 
  Nil -> Nothing
  Cons h l' -> case i of
    Zero -> Just h
    Succ j -> idxl [a] l' j

idxv : [a: Type] -> [n: Nat] -> Vec a n -> (i: Fin n) -> (a)
idxv = \[a] [n] v i . case i of 
  Zero [_] -> case v of 
    Cons [n'] h l' -> h
  Succ [nj'] j -> case v of
    Cons [n'] h l' -> idxv [a] [n'] l' j

successors : (n: Nat) -> (Graph n) -> (u : Fin n) -> (List Node)
successors = \n g u . case g of 
    G v -> case v of 
      Nil -> Nil
      Cons [m] h tl -> idxv [List Node] [Succ m] v u 

--successors = \n g u . case n of 
--  Zero -> Nil
--  Succ m -> case g of 
--    G v -> idxv [List Node] [n] v u 

contains_nat : List Nat -> Nat -> Bool
contains_nat = \l x . case l of
  Nil -> False
  Cons h tl -> if (nat_eq x h) then True else (contains_nat tl x)
 
-- Rather than explicit contains, just use filter equals?
is_pred : (n: Nat) -> (Graph n) -> (u: Fin n) -> (v: Fin n) -> Maybe (Fin n) -- Return u if u is a predecessor of v, else nothing
is_pred = \n g u v . let succs = successors n g v in
  case (contains_nat succs (toNat [n] u)) of
    False -> Nothing
    True -> Just v

contains_maybe : [a: Type] -> a -> Nat -> List Nat -> Maybe a
contains_maybe = \[a] ret n lst . case (contains_nat lst n) of
  False -> Nothing
  True -> Just ret

--maybe_pred_single : Node -> Node -> Maybe Node
--maybe_pred_single = \target n . case n of
--  AdjList n_succs -> case filter [Node] (\x . x = target) n_succs of
--    Nil -> Nothing
--    Cons a a' -> Just a

maybe_preds : [n: Nat] -> (g: Graph n) -> Fin n -> (Vec (Maybe Node) n)
maybe_preds = \[n] g u. case g of
  G v -> vecmap [List Node] [Maybe Node] [n] (contains_maybe [Node]  (toNat [n] u) (toNat [n] u)) v

maybe_v2l : [A: Type] -> [n: Nat] -> Vec (Maybe A) n -> List A
maybe_v2l = \[A][n] v .
  case v of
    Nil -> Nil
    Cons [n'] x xs -> let p = (maybe_v2l [A] [n'] xs) in
      case x of
        Just y -> Cons y p
        Nothing -> p


predecessors : [n: Nat] -> (g : Graph n) -> Fin n -> (List Node)
predecessors = \[n] g u . let pred_or_nothing_vec = maybe_preds [n] g u in
  maybe_v2l [Node] [n] pred_or_nothing_vec

-- Graph in which every node has an edge going to node 0
-- InwardSpokeGraph : Type
-- InwardSpokeGraph = {n : Nat | ((Graph n) *  }